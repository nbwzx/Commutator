<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Zixing Wang">
  <meta name="generator" content="Hugo 0.88.1">
  <title>Commutator</title>
  <link rel="canonical" href="https://getbootstrap.com/docs/5.1/examples/navbar-fixed/">
  <!-- Bootstrap core CSS -->
  <link href="assets/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="assets/dist/css/prism.css" rel="stylesheet">
  <link rel="icon" href="assets/images/logo.ico" type="image/x-icon" />
  <style>
    .bd-placeholder-img {
      font-size: 1.125rem;
      text-anchor: middle;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
    }

    @media (min-width: 768px) {
      .bd-placeholder-img-lg {
        font-size: 3.5rem;
      }
    }
  </style>


  <!-- Custom styles for this template -->
  <link href="assets/dist/css/navbar-top-fixed.css" rel="stylesheet">

</head>

<body>

  <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
    <div class="container-fluid">
      <a class="navbar-brand" href="#">Commutator</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse"
        aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarCollapse">
        <ul class="navbar-nav me-auto mb-2 mb-md-0">
          <li class="nav-item">
            <a class="nav-link" href="index.html">&nbsp;&nbsp;Home&nbsp;&nbsp;</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="introduction.html">&nbsp;&nbsp;Introduction&nbsp;&nbsp;</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="cube.html">&nbsp;&nbsp;Rubik's cube&nbsp;&nbsp;</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="free.html">&nbsp;&nbsp;Free group&nbsp;&nbsp;</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="cube.html">&nbsp;&nbsp;Excel&nbsp;&nbsp;</a>
          </li>
          <li class="nav-item">
            <a class="nav-link active" aria-current="page" href="#">&nbsp;&nbsp;Source code&nbsp;&nbsp;</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/nbwzx/Commutator" target="blank">&nbsp;&nbsp;Github
              repository&nbsp;&nbsp;</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="about.html">&nbsp;&nbsp;About&nbsp;&nbsp;</a>
          </li>
        </ul>
        <!-- <form class="d-flex">
          <input class="form-control me-2" type="search" placeholder="Search" aria-label="Search">
          <button class="btn btn-outline-success" type="submit">Search</button>
        </form> -->
      </div>
    </div>
  </nav>

  <main class="container">
    <br>
    <h2 class="border-1 border-bottom border-dark">The Source Code</h2>
    <pre class="line-numbers"><code class="language-javascript">
      "use strict";

      function expand() {
          let algValue = String(document.getElementById("alg").value);
          if (algValue.toString() === "".toString()) {
              document.getElementById("alert").classList.add("invisible");
              document.getElementById("alert").innerHTML = "Empty input.";
              document.getElementById("alert").classList.remove("invisible");
              return;
          }
          algValue = algValue.replace(/\(/gu, "[");
          algValue = algValue.replace(/\)/gu, "]");
          algValue = algValue.replace(/\]\[/gu, "]+[");
          const expression = rpn(initializeExperssion(algValue));
          if (expression === "Lack left parenthesis." || expression === "Lack right parenthesis.") {
              document.getElementById("alert").classList.add("invisible");
              document.getElementById("alert").innerHTML = expression;
              document.getElementById("alert").classList.remove("invisible");
          } else {
              document.getElementById("alert").classList.add("invisible");
              document.getElementById("alert").innerHTML = simplifyfinal(preprocessing(calculate(expression)));
              document.getElementById("alert").classList.remove("invisible");
          }
      }
      
      function isOperator(val) {
          const operatorString = "+:,[]";
          return operatorString.indexOf(val) > -1;
      }
      
      function initializeExperssion(expressionOrigin) {
          const expression = expressionOrigin.replace(/\s/gu, ""),
              inputStack = [];
          inputStack.push(expression[0]);
          for (let i = 1; i < expression.length; i++) {
              if (isOperator(expression[i]) || isOperator(inputStack.slice(-1))) {
                  inputStack.push(expression[i]);
              } else {
                  inputStack.push(inputStack.pop() + expression[i]);
              }
          }
          return inputStack;
      }
      
      function operatorLevel(operator) {
          if (operator === "+") {
              return 0;
          }
          if (operator === ",") {
              return 1;
          }
          if (operator === ":") {
              return 2;
          }
          if (operator === "[") {
              return 3;
          }
          if (operator === "]") {
              return 4;
          }
          return null;
      }
      
      function rpn(inputStack) {
          // Reverse Polish Notation
          const outputStack = [],
              operatorStack = [];
          let match = false,
              tempOperator = "";
          while (inputStack.length > 0) {
              const sign = inputStack.shift();
              if (!isOperator(sign)) {
                  outputStack.push(sign);
              } else if (operatorLevel(sign) === 4) {
                  match = false;
                  while (operatorStack.length > 0) {
                      tempOperator = operatorStack.pop();
                      if (tempOperator === "[") {
                          match = true;
                          break;
                      } else {
                          outputStack.push(tempOperator);
                      }
                  }
                  if (match === false) {
                      return "Lack left parenthesis.";
                  }
              } else {
                  while (operatorStack.length > 0 && operatorStack.slice(-1) !== "[" && operatorLevel(sign) <= operatorLevel(operatorStack.slice(-1))) {
                      outputStack.push(operatorStack.pop());
                  }
                  operatorStack.push(sign);
              }
          }
          while (operatorStack.length > 0) {
              tempOperator = operatorStack.pop();
              if (tempOperator === "[") {
                  return "Lack right parenthesis.";
              }
              outputStack.push(tempOperator);
          }
          return outputStack;
      }
      
      function calculate(expression) {
          let i = 0,
              j = 0;
          const rpnExpression = [];
          while (expression.length > 0) {
              const sign = expression.shift();
              if (isOperator(sign)) {
                  j = rpnExpression.pop();
                  i = rpnExpression.pop();
                  rpnExpression.push(calculateTwo(i, j, sign));
              } else {
                  rpnExpression.push(sign);
              }
          }
          return rpnExpression[0];
      }
      
      function calculateTwo(i, j, sign) {
          let arr1 = [],
              arr2 = [];
          if (typeof i !== "undefined") {
              arr1 = preprocessing(i);
          }
          if (typeof j !== "undefined") {
              arr2 = preprocessing(j);
          }
          switch (sign) {
              case "+":
                  return simplifyfinal(arr1.concat(arr2));
              case ":":
                  return simplifyfinal(arr1.concat(arr2, inverse(arr1.concat())));
              case ",":
                  return simplifyfinal(arr1.concat(arr2, inverse(arr1.concat()), inverse(arr2.concat())));
              default:
                  return false;
          }
      }
      
      
      function cube() {
          const algValue = String(document.getElementById("alg").value);
          document.getElementById("alert").classList.add("invisible");
          document.getElementById("alert").innerHTML = commutator(algValue);
          document.getElementById("alert").classList.remove("invisible");
      }
      
      function commutator(x) {
          const order = 4;
          if (x.toString() === "".toString()) {
              return "Empty input.";
          }
          const arr1 = preprocessing(x);
          if (arr1.length === 0) {
              return "Empty input.";
          }
          for (let i = 0; i < arr1.length - 1; i++) {
              if (arr1[i].length > 2) {
                  return "Invalid input.";
              }
          }
          let sum = 0;
          for (let i = 0; i <= arr1.length - 1; i++) {
              sum = 0;
              for (let j = 0; j <= arr1.length - 1; j++) {
                  if (arr1[i][0] === arr1[j][0]) {
                      if (arr1[j].length === 1) {
                          sum += 1;
                      } else {
                          if (arr1[j][1] === "2") {
                              sum += 2;
                          }
                          if (arr1[j][1] === "'") {
                              sum -= 1;
                          }
                      }
                  }
              }
              if (sum % order !== 0) {
                  return "Not found.";
              }
          }
          const textOutput = commutatormain(arr1);
          if (textOutput.toString() !== "Not found.".toString()) {
              return OuterBracket(textOutput);
          }
          const part3 = conjugate(arr1),
              arrex = simplify(inverse(part3.concat()).concat(arr1, part3));
          return OuterBracket(commutatorpair(arrex, part3));
      }
      
      function OuterBracket(str) {
          if (document.getElementById("settingsOuterBracket").checked === false) {
              return str;
          }
          if ((str.charAt(0) == "[" && str.charAt(str.length - 1) == "]") || str.toString() === "Not found.".toString()) {
              return str;
          }
          return `[${str}]`;
      }
      
      function preprocessing(algValue) {
          let x = "";
          x = algValue.trim();
          x = x.split("").join(" ");
          x = x.replace(/\s+/igu, " ");
          x = x.replace(/[‘]/gu, "'");
          x = x.replace(/[’]/gu, "'");
          x = x.replace(/ '/gu, "'");
          x = x.replace(/ 2/gu, "2");
          x = x.replace(/2'/gu, "2");
          x = x.replace(/'2/gu, "2");
          if (x.indexOf("R") > -1 || x.indexOf("M") > -1) {
              x = x.replace(/r2/gu, "R2 M2");
              x = x.replace(/r'/gu, "R' M");
              x = x.replace(/r/gu, "R M'");
          }
          if (x.indexOf("L") > -1 || x.indexOf("M") > -1) {
              x = x.replace(/l2/gu, "L2 M2");
              x = x.replace(/l'/gu, "L' M'");
              x = x.replace(/l/gu, "L M");
          }
          if (x.indexOf("F") > -1 || x.indexOf("S") > -1) {
              x = x.replace(/f2/gu, "F2 S2");
              x = x.replace(/f'/gu, "F' S'");
              x = x.replace(/f/gu, "F S");
          }
          if (x.indexOf("B") > -1 || x.indexOf("S") > -1) {
              x = x.replace(/b2/gu, "B2 S2");
              x = x.replace(/b'/gu, "B' S");
              x = x.replace(/b/gu, "B S'");
          }
          if (x.indexOf("U") > -1 || x.indexOf("E") > -1) {
              x = x.replace(/u2/gu, "U2 E2");
              x = x.replace(/u'/gu, "U' E");
              x = x.replace(/u/gu, "U E'");
          }
          if (x.indexOf("D") > -1 || x.indexOf("E") > -1) {
              x = x.replace(/d2/gu, "D2 E2");
              x = x.replace(/d'/gu, "D' E'");
              x = x.replace(/d/gu, "D E");
          }
          let arr1 = simplify(x.split(" "));
          // Handle cases like R2 M2 E' R' U' R E R' U R' M2
          const similarstr = "UD DU UE EU DE ED RM MR RL LR LM ML FS SF FB BF SB BS";
          if (arr1.length > 1) {
              if (similarstr.toString().indexOf(arr1[0][0].toString() + arr1[1][0].toString()) > -1) {
                  if (arr1[1][0] === arr1[arr1.length - 1][0]) {
                      arr1 = swaparr(arr1, 0, 1);
                  }
              }
              if (similarstr.toString().indexOf(arr1[arr1.length - 2][0].toString() + arr1[arr1.length - 1][0].toString()) > -1) {
                  if (arr1[arr1.length - 2][0] === arr1[0][0]) {
                      arr1 = swaparr(arr1, arr1.length - 2, arr1.length - 1);
                  }
              }
          }
          return arr1;
      }
      
      function commutatorpair(array, part3) {
          let arrtemp = array.concat(),
              minscore = 10000,
              temp = 0,
              output0b = "",
              partb0 = "",
              outputb = [],
              outputb0 = "",
              outputa1 = "",
              outputa2 = "",
              outputb1 = "",
              outputb2 = "",
              text1 = "";
          const lenarr1 = arrtemp.length;
          if (lenarr1 < 4) {
              return "Not found.";
          }
          for (let displaceIndex = 0; displaceIndex < lenarr1; displaceIndex++) {
              for (let i = 1; i <= lenarr1 / 2; i++) {
                  const str1 = arrtemp.concat().slice(0, i);
                  for (let j = 1; j <= lenarr1 / 2; j++) {
                      const str2 = arrtemp.concat().slice(i, i + j),
                          part1x = simplify(str1),
                          part2x = simplify(str2),
                          party = simplify(part2x.concat(part1x));
                      let part1 = part1x,
                          part2 = part2x;
                      // For U R' F R2 D' R' D R' F' R U' D' R D R', output [U R' F R,R D' R' D] instead of [U R' F R2 D' R' D,R D' R' D]
                      if (party.length < Math.max(part1x.length, part2x.length)) {
                          if (part1x.length <= part2x.length) {
                              part1 = part1x;
                              part2 = party;
                          } else {
                              part1 = inverse(part2x.concat());
                              part2 = party;
                          }
                      }
                      const arrex = part1.concat(part2, inverse(part1.concat()), inverse(part2.concat())),
                          arra = simplify(arrex),
                          arrb = simplify(inverse(arra.concat()).concat(arrtemp)),
                          partb = commutatormain(arrb);
                      if (partb.toString() !== "Not found.".toString()) {
                          const realscore0 = part1.length + part2.length + Math.min(part1.length, part2.length),
                              parta1 = simplifyfinal(part1),
                              parta2 = simplifyfinal(part2);
                          if (partb.toString().indexOf(":".toString()) > -1) {
                              partb0 = `${partb.split(":")[0]}:`;
                          } else {
                              partb0 = "";
                          }
                          const partb1 = partb.split("[")[1].split(",")[0],
                              partb2 = partb.split(",")[1].split("]")[0],
                              realscore = partb1.split(" ").length + partb2.split(" ").length + Math.min(partb1.split(" ").length, partb2.split(" ").length) + realscore0;
                          if (realscore < minscore) {
                              if (displaceIndex === 0) {
                                  output0b = "";
                              } else {
                                  output0b = array.concat().slice(0, displaceIndex);
                              }
                              outputb = arrb;
                              outputb0 = partb0;
                              outputa1 = parta1;
                              outputa2 = parta2;
                              outputb1 = partb1;
                              outputb2 = partb2;
                              temp = 1;
                              minscore = realscore;
                          }
                      }
                  }
              }
              arrtemp = displace(arrtemp);
          }
          if (temp === 0) {
              return "Not found.";
          }
          let output0 = simplify(part3);
          if (output0b.toString() !== "".toString()) {
              output0 = simplify(part3.concat(output0b));
          }
          let output0x = "None";
          if (output0.toString() !== "".toString()) {
              output0x = simplify(output0.concat(inverse(outputb.concat())));
          }
          if (output0x.length < output0.length && output0x.toString() !== "None".toString()) {
              if (output0x.toString() === "".toString()) {
                  text1 = `${outputb0}[${outputb1},${outputb2}]+[${outputa1},${outputa2}]`;
              } else {
                  const outputbarr0 = outputb0.split(":")[0].split(" "),
                      output0y = simplify(output0x.concat(outputbarr0));
                  if (output0y.length < output0x.length) {
                      if (output0y.toString() === "".toString()) {
                          text1 = `[${outputb1},${outputb2}]+${simplifyfinal(inverse(outputbarr0.concat()))}:[${outputa1},${outputa2}]`;
                      } else {
                          text1 = `${simplifyfinal(output0y)}:[[${outputb1},${outputb2}]+${simplifyfinal(inverse(outputbarr0.concat()))}:[${outputa1},${outputa2}]]`;
                      }
                  } else {
                      text1 = `${simplifyfinal(output0x)}:[${outputb0}[${outputb1},${outputb2}]+[${outputa1},${outputa2}]]`;
                  }
              }
              return text1;
          }
          if (output0.toString() === "".toString()) {
              text1 = `[${outputa1},${outputa2}]+${outputb0}[${outputb1},${outputb2}]`;
          } else {
              text1 = `${simplifyfinal(output0)}:[[${outputa1},${outputa2}]+${outputb0}[${outputb1},${outputb2}]]`;
          }
          return text1;
      }
      
      function commutatormain(array) {
          const arr0 = array.concat(),
              part3 = conjugate(arr0),
              penaltyFactor = 2;
          let arr1 = simplify(inverse(part3.concat()).concat(arr0, part3)),
              minscore = 2000,
              mini = 0,
              realscore = 0,
              arrtemp = arr1.concat(),
              part4 = "";
          for (let i = 0; i < arrtemp.length; i++) {
              const scoreTemp = score(arrtemp.concat());
              if (i <= arrtemp.length / 2) {
                  realscore = scoreTemp + i / (penaltyFactor + 1);
              }
              if (i > arrtemp.length / 2) {
                  realscore = scoreTemp + penaltyFactor * (arrtemp.length - i) / (penaltyFactor + 1);
              }
              if (realscore < minscore) {
                  mini = i;
                  minscore = realscore;
              }
              arrtemp = displace(arrtemp);
          }
          if (mini <= arrtemp.length / 2) {
              part4 = arr1.concat().slice(0, mini);
              arr1 = simplify(inverse(part4.concat()).concat(arr1, part4));
          } else {
              part4 = arr1.concat().slice(mini, arrtemp.length);
              arr1 = simplify(part4.concat().concat(arr1, inverse(part4)));
          }
          const part5 = simplify(part3.concat(part4)),
              part5Output = simplifyfinal(part5),
              lenarr1 = arr1.length;
          for (let i = 1; i <= lenarr1 / 2; i++) {
              const str1 = arr1.concat().slice(0, i);
              for (let j = 1; j <= lenarr1 / 2; j++) {
                  const str2 = arr1.concat().slice(i, i + j),
                      part1x = simplify(str1),
                      part2x = simplify(str2),
                      party = simplify(part2x.concat(part1x));
                  let part1 = part1x,
                      part2 = part2x;
                  // For U R' F R2 D' R' D R' F' R U' D' R D R', output [U R' F R,R D' R' D] instead of [U R' F R2 D' R' D,R D' R' D]
                  if (party.length < Math.max(part1x.length, part2x.length)) {
                      if (part1x.length <= part2x.length) {
                          part1 = part1x;
                          part2 = party;
                      } else {
                          part1 = inverse(part2x.concat());
                          part2 = party;
                      }
                  }
                  const arrex = part1.concat(part2, inverse(part1.concat()), inverse(part2.concat())),
                      arr = simplify(arrex),
                      part1Output = simplifyfinal(part1),
                      part2Output = simplifyfinal(part2);
                  if (simplify(arr.concat(inverse(arr1.concat()))).length === 0) {
                      if (part5.length === 0) {
                          return `[${part1Output},${part2Output}]`;
                      }
                      if (part5.length > 0) {
                          return `${part5Output}:[${part1Output},${part2Output}]`;
                      }
                  }
              }
          }
          return "Not found.";
      }
      // R2 D R U' R D' R' U R D R' U R' D' R U' R
      
      function displace(array) {
          const arr = array.concat(),
              arr1 = arr.concat().slice(0, 1),
              arr2 = arr.concat().slice(arr.length - 1, arr.length);
          let arrtemp = [];
          if (combineTwo(arr1[0], arr2[0]).toString() === "0".toString()) {
              arrtemp = arr.concat();
              arrtemp = inverse(arr1.concat()).concat(arrtemp, arr1);
              arrtemp = simplify(arrtemp);
          } else {
              arrtemp = arr.concat();
              arrtemp = arr2.concat(arrtemp, inverse(arr2.concat()));
              arrtemp = simplify(arrtemp);
          }
          return arrtemp;
      }
      
      function score(array) {
          const arr1 = array.concat(),
              lenarr1 = arr1.length,
              scoreNotFound = 1000;
          for (let i = 1; i <= lenarr1 / 2; i++) {
              const str1 = arr1.concat().slice(0, i);
              for (let j = 1; j <= lenarr1 / 2; j++) {
                  const str2 = arr1.concat().slice(i, i + j),
                      part1x = simplify(str1),
                      part2x = simplify(str2),
                      party = simplify(part2x.concat(part1x));
                  let part1 = part1x,
                      part2 = part2x;
                  // For U R' F R2 D' R' D R' F' R U' D' R D R', output [U R' F R,R D' R' D] instead of [U R' F R2 D' R' D,R D' R' D]
                  if (party.length < Math.max(part1x.length, part2x.length)) {
                      if (part1x.length <= part2x.length) {
                          part1 = part1x;
                          part2 = party;
                      } else {
                          part1 = inverse(part2x.concat());
                          part2 = party;
                      }
                  }
                  const arrex = part1.concat(part2, inverse(part1.concat()), inverse(part2.concat())),
                      arr = simplify(arrex);
                  if (simplify(arr.concat(inverse(arr1.concat()))).length === 0) {
                      return part1.length + part2.length + Math.min(part1.length, part2.length);
                  }
              }
          }
          return scoreNotFound;
      }
      
      function conjugate(array) {
          const arr = array.concat();
          let minlen = arr.length,
              t = 0;
          for (let i = 1; i < array.length; i++) {
              const arr1 = arr.concat().slice(0, i),
                  arr2 = inverse(arr1.concat());
              let arrtemp = arr.concat();
              arrtemp = arr2.concat(arrtemp, arr1);
              arrtemp = simplify(arrtemp);
              const len = simplify(arrtemp).length;
              if (len < minlen) {
                  t = i;
                  minlen = len;
              }
          }
          // For  R' U2 R' D R U R' D' R U R, output R' U':[U',R' D R] instead of R' U2:[R' D R,U]
          if (t > 0) {
              if (arr[t - 1].length > 1) {
                  if (arr[t - 1][1].toString() === "2".toString()) {
                      return simplify(arr.concat().slice(0, t - 1).concat(inverse(arr.concat().slice(arr.length - t, arr.length - (t - 1)))));
                  }
              }
          }
          return arr.concat().slice(0, t);
      }
      
      function inverse(array) {
          const arr = array.concat();
          for (let i = 0; i < arr.length / 2; i++) {
              const temp = arr[i];
              arr[i] = array[arr.length - 1 - i];
              arr[arr.length - 1 - i] = temp;
          }
          for (let i = 0; i < arr.length; i++) {
              arr[i] = inverseOne(arr[i]);
          }
          return arr;
      }
      
      function simplifyfinal(array) {
          let arr = array.concat();
          arr = simplify(arr);
          if (arr.length === 0) {
              return "";
          }
          for (let i = 0; i < arr.length - 1; i++) {
              if (arr[i][0].toString() === "D".toString() && arr[i + 1][0].toString() === "U".toString()) {
                  arr = swaparr(arr, i, i + 1);
              }
              if (arr[i][0].toString() === "B".toString() && arr[i + 1][0].toString() === "F".toString()) {
                  arr = swaparr(arr, i, i + 1);
              }
              if (arr[i][0].toString() === "L".toString() && arr[i + 1][0].toString() === "R".toString()) {
                  arr = swaparr(arr, i, i + 1);
              }
          }
          let arrOutput = `${arr.join(" ")} `;
          arrOutput = arrOutput.replace(/R2 M2 /gu, "r2 ");
          arrOutput = arrOutput.replace(/R' M /gu, "r' ");
          arrOutput = arrOutput.replace(/R M' /gu, "r ");
          arrOutput = arrOutput.replace(/L2 M2 /gu, "l2 ");
          arrOutput = arrOutput.replace(/L' M' /gu, "l' ");
          arrOutput = arrOutput.replace(/L M /gu, "l ");
          arrOutput = arrOutput.replace(/F2 S2 /gu, "f2 ");
          arrOutput = arrOutput.replace(/F' S' /gu, "f' ");
          arrOutput = arrOutput.replace(/F S /gu, "f ");
          arrOutput = arrOutput.replace(/B2 S2 /gu, "b2 ");
          arrOutput = arrOutput.replace(/B' S /gu, "b' ");
          arrOutput = arrOutput.replace(/B S' /gu, "b ");
          arrOutput = arrOutput.replace(/U2 E2 /gu, "u2 ");
          arrOutput = arrOutput.replace(/U' E /gu, "u' ");
          arrOutput = arrOutput.replace(/U E' /gu, "u ");
          arrOutput = arrOutput.replace(/D2 E2 /gu, "d2 ");
          arrOutput = arrOutput.replace(/D' E' /gu, "d' ");
          arrOutput = arrOutput.replace(/D E /gu, "d ");
          arrOutput = arrOutput.replace(/M2 R2 /gu, "r2 ");
          arrOutput = arrOutput.replace(/M R' /gu, "r' ");
          arrOutput = arrOutput.replace(/M' R /gu, "r ");
          arrOutput = arrOutput.replace(/M2 L2 /gu, "l2 ");
          arrOutput = arrOutput.replace(/M' L' /gu, "l' ");
          arrOutput = arrOutput.replace(/M L /gu, "l ");
          arrOutput = arrOutput.replace(/S2 F2 /gu, "f2 ");
          arrOutput = arrOutput.replace(/S' F' /gu, "f' ");
          arrOutput = arrOutput.replace(/S F /gu, "f ");
          arrOutput = arrOutput.replace(/S2 B2 /gu, "b2 ");
          arrOutput = arrOutput.replace(/S B' /gu, "b' ");
          arrOutput = arrOutput.replace(/S' B /gu, "b ");
          arrOutput = arrOutput.replace(/E2 U2 /gu, "u2 ");
          arrOutput = arrOutput.replace(/E U' /gu, "u' ");
          arrOutput = arrOutput.replace(/E' U /gu, "u ");
          arrOutput = arrOutput.replace(/E2 D2 /gu, "d2 ");
          arrOutput = arrOutput.replace(/E' D' /gu, "d' ");
          arrOutput = arrOutput.replace(/E D /gu, "d ");
          arrOutput = arrOutput.replace(/R M2 /gu, "r M' ");
          arrOutput = arrOutput.replace(/R' M2 /gu, "r' M ");
          arrOutput = arrOutput.replace(/M2 R /gu, "r M' ");
          arrOutput = arrOutput.replace(/M2 R' /gu, "r' M ");
          arrOutput = arrOutput.substring(0, arrOutput.length - 1);
          return arrOutput;
      }
      
      function simplify(array) {
          const len = array.length;
          let arr = array.concat();
          for (let i = 0; i <= len; i++) {
              arr = simple(arr);
          }
          return arr;
      }
      
      function simple(array) {
          const arr = array.concat();
          for (let i = 0; i < arr.length - 1; i++) {
              if (combineTwo(arr[i], arr[i + 1]).toString() === "".toString()) {
                  arr.splice(i, 2);
                  break;
              }
              if (combineTwo(arr[i], arr[i + 1]).toString() === arr[i][0].toString()) {
                  arr.splice(i + 2, 0, arr[i][0]);
                  arr.splice(i, 2);
                  break;
              }
              if (combineTwo(arr[i], arr[i + 1]).toString() === `${arr[i][0]}2`.toString()) {
                  arr.splice(i + 2, 0, `${arr[i][0]}2`);
                  arr.splice(i, 2);
                  break;
              }
              if (combineTwo(arr[i], arr[i + 1]).toString() === `${arr[i][0]}'`.toString()) {
                  arr.splice(i + 2, 0, `${arr[i][0]}'`);
                  arr.splice(i, 2);
                  break;
              }
          }
          for (let i = 0; i < arr.length - 2; i++) {
              const similarstr = "UD DU UE EU DE ED RM MR RL LR LM ML FS SF FB BF SB BS";
              if (similarstr.toString().indexOf(arr[i][0].toString() + arr[i + 1][0].toString()) > -1) {
                  if (combineTwo(arr[i], arr[i + 2]).toString() === "".toString()) {
                      arr.splice(i + 2, 1);
                      arr.splice(i, 1);
                      break;
                  }
                  if (combineTwo(arr[i], arr[i + 2]).toString() === arr[i][0].toString()) {
                      arr.splice(i + 3, 0, arr[i][0]);
                      arr.splice(i + 2, 1);
                      arr.splice(i, 1);
                      break;
                  }
                  if (combineTwo(arr[i], arr[i + 2]).toString() === `${arr[i][0]}2`.toString()) {
                      arr.splice(i + 3, 0, `${arr[i][0]}2`);
                      arr.splice(i + 2, 1);
                      arr.splice(i, 1);
                      break;
                  }
                  if (combineTwo(arr[i], arr[i + 2]).toString() === `${arr[i][0]}'`.toString()) {
                      arr.splice(i + 3, 0, `${arr[i][0]}'`);
                      arr.splice(i + 2, 1);
                      arr.splice(i, 1);
                      break;
                  }
              }
          }
          return arr;
      }
      
      function combineTwo(str1, str2) {
          const len1 = str1.length,
              len2 = str2.length;
          if (str1[0] === str2[0]) {
              if (len1 === 1) {
                  if (len2 === 1) {
                      return `${str1}2`;
                  }
                  if (len2 === 2) {
                      if (str2[1] === "2") {
                          return `${str1}'`;
                      }
                      if (str2[1] === "'") {
                          return "";
                      }
                  }
              }
              if (len1 === 2) {
                  if (str1[1] === "'") {
                      if (len2 === 1) {
                          return "";
                      }
                      if (len2 === 2) {
                          if (str2[1] === "2") {
                              return str1[0];
                          }
                          if (str2[1] === "'") {
                              return `${str1[0]}2`;
                          }
                      }
                  }
                  if (str1[1] === "2") {
                      if (len2 === 1) {
                          return `${str1[0]}'`;
                      }
                      if (len2 === 2) {
                          if (str2[1] === "2") {
                              return "";
                          }
                          if (str2[1] === "'") {
                              return str1[0];
                          }
                      }
                  }
              }
          }
          return "0";
      }
      
      function inverseOne(str) {
          const len = str.length;
          if (len === 1) {
              return `${str}'`;
          }
          if (len === 2) {
              if (str[1] === "2") {
                  return str;
              }
              if (str[1] === "'") {
                  return str[0];
              }
          }
          return null;
      }
      
      function swaparr(arr, index1, index2) {
          arr[index1] = arr.splice(index2, 1, arr[index1])[0];
          return arr;
      }
      
      document.getElementById("cube").addEventListener("click", cube);
      document.getElementById("expand").addEventListener("click", expand);
    </code>
      </pre>
  </main>
  <script src="assets/dist/js/bootstrap.bundle.min.js"></script>
  <script src="assets/dist/js/prism.js"></script>
</body>
</html>