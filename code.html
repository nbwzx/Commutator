<!doctype html>
<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="Zixing Wang">
  <meta name="generator" content="Hugo 0.88.1">
  <title>Commutator</title>
  <link rel="canonical" href="https://getbootstrap.com/docs/5.1/examples/navbar-fixed/">
  <!-- Bootstrap core CSS -->
  <link href="assets/dist/css/bootstrap.min.css" rel="stylesheet">
  <link href="assets/dist/css/prism.css" rel="stylesheet">
  <link rel="icon" href="assets/images/logo.ico" type="image/x-icon" />
  <style>
    .bd-placeholder-img {
      font-size: 1.125rem;
      text-anchor: middle;
      -webkit-user-select: none;
      -moz-user-select: none;
      user-select: none;
    }

    @media (min-width: 768px) {
      .bd-placeholder-img-lg {
        font-size: 3.5rem;
      }
    }
  </style>


  <!-- Custom styles for this template -->
  <link href="assets/dist/css/navbar-top-fixed.css" rel="stylesheet">

</head>

<body>

  <nav class="navbar navbar-expand-md navbar-dark fixed-top bg-dark">
    <div class="container-fluid">
      <a class="navbar-brand" href="#">Commutator</a>
      <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse"
        aria-controls="navbarCollapse" aria-expanded="false" aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
      </button>
      <div class="collapse navbar-collapse" id="navbarCollapse">
        <ul class="navbar-nav me-auto mb-2 mb-md-0">
          <li class="nav-item">
            <a class="nav-link" href="index.html">&nbsp;&nbsp;Home&nbsp;&nbsp;</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="introduction.html">&nbsp;&nbsp;Introduction&nbsp;&nbsp;</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="cube.html">&nbsp;&nbsp;Rubik's cube&nbsp;&nbsp;</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="free.html">&nbsp;&nbsp;Free group&nbsp;&nbsp;</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="cube.html">&nbsp;&nbsp;Excel&nbsp;&nbsp;</a>
          </li>
          <li class="nav-item">
            <a class="nav-link active" aria-current="page" href="#">&nbsp;&nbsp;Source code&nbsp;&nbsp;</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="https://github.com/nbwzx/Commutator" target="blank">&nbsp;&nbsp;Github
              repository&nbsp;&nbsp;</a>
          </li>
          <li class="nav-item">
            <a class="nav-link" href="about.html">&nbsp;&nbsp;About&nbsp;&nbsp;</a>
          </li>
        </ul>
        <!-- <form class="d-flex">
          <input class="form-control me-2" type="search" placeholder="Search" aria-label="Search">
          <button class="btn btn-outline-success" type="submit">Search</button>
        </form> -->
      </div>
    </div>
  </nav>

  <main class="container">
    <br>
    <h2 class="border-1 border-bottom border-dark">The Source Code</h2>
    <pre class="line-numbers"><code class="language-javascript">
        "use strict";

        function expand() {
            let algValue = String(document.getElementById("alg").value);
            if (algValue.toString() === "".toString()) {
                document.getElementById("alert").classList.add("invisible");
                document.getElementById("alert").innerHTML = "Empty input.";
                document.getElementById("alert").classList.remove("invisible");
                return;
            }
            algValue = algValue.replace(/\(/gu, "[");
            algValue = algValue.replace(/\)/gu, "]");
            algValue = algValue.replace(/\]\[/gu, "]+[");
            const expression = rpn(initializeExperssion(algValue));
            if (expression === "Lack left parenthesis." || expression === "Lack right parenthesis.") {
                document.getElementById("alert").classList.add("invisible");
                document.getElementById("alert").innerHTML = expression;
                document.getElementById("alert").classList.remove("invisible");
            } else {
                document.getElementById("alert").classList.add("invisible");
                document.getElementById("alert").innerHTML = simplifyfinal(preprocessing(calculate(expression)));
                document.getElementById("alert").classList.remove("invisible");
            }
        }
        
        function isOperator(val) {
            const operatorString = "+:,[]";
            return operatorString.indexOf(val) > -1;
        }
        
        function initializeExperssion(expressionOrigin) {
            const expression = expressionOrigin.replace(/\s/gu, ""),
                inputStack = [];
            inputStack.push(expression[0]);
            for (let i = 1; i < expression.length; i++) {
                if (isOperator(expression[i]) || isOperator(inputStack.slice(-1))) {
                    inputStack.push(expression[i]);
                } else {
                    inputStack.push(inputStack.pop() + expression[i]);
                }
            }
            return inputStack;
        }
        
        function operatorLevel(operator) {
            if (operator === ",") {
                return 0;
            }
            if (operator === ":") {
                return 1;
            }
            if (operator === "+") {
                return 2;
            }
            if (operator === "[") {
                return 3;
            }
            if (operator === "]") {
                return 4;
            }
            return null;
        }
        
        function rpn(inputStack) {
            // Reverse Polish Notation
            const outputStack = [],
                operatorStack = [];
            let match = false,
                tempOperator = "";
            while (inputStack.length > 0) {
                const sign = inputStack.shift();
                if (!isOperator(sign)) {
                    outputStack.push(sign);
                } else if (operatorLevel(sign) === 4) {
                    match = false;
                    while (operatorStack.length > 0) {
                        tempOperator = operatorStack.pop();
                        if (tempOperator === "[") {
                            match = true;
                            break;
                        } else {
                            outputStack.push(tempOperator);
                        }
                    }
                    if (match === false) {
                        return "Lack left parenthesis.";
                    }
                } else {
                    while (operatorStack.length > 0 && operatorStack.slice(-1).toString() !== "[".toString() && operatorLevel(sign) <= operatorLevel(operatorStack.slice(-1))) {
                        outputStack.push(operatorStack.pop());
                    }
                    operatorStack.push(sign);
                }
            }
            while (operatorStack.length > 0) {
                tempOperator = operatorStack.pop();
                if (tempOperator === "[") {
                    return "Lack right parenthesis.";
                }
                outputStack.push(tempOperator);
            }
            return outputStack;
        }
        
        function calculate(expression) {
            let i = 0,
                j = 0;
            const rpnExpression = [];
            while (expression.length > 0) {
                const sign = expression.shift();
                if (isOperator(sign)) {
                    j = rpnExpression.pop();
                    i = rpnExpression.pop();
                    rpnExpression.push(calculateTwo(i, j, sign));
                } else {
                    rpnExpression.push(sign);
                }
            }
            return rpnExpression[0];
        }
        
        function calculateTwo(i, j, sign) {
            let arr1 = [],
                arr2 = [];
            if (typeof i !== "undefined") {
                arr1 = preprocessing(i);
            }
            if (typeof j !== "undefined") {
                arr2 = preprocessing(j);
            }
            switch (sign) {
                case "+":
                    return simplifyfinal(arr1.concat(arr2));
                case ":":
                    return simplifyfinal(arr1.concat(arr2, inverse(arr1.concat())));
                case ",":
                    return simplifyfinal(arr1.concat(arr2, inverse(arr1.concat()), inverse(arr2.concat())));
                default:
                    return false;
            }
        }
        
        function cube() {
            const algValue = String(document.getElementById("alg").value);
            document.getElementById("alert").classList.add("invisible");
            // console.time("Time");
            document.getElementById("alert").innerHTML = commutator(algValue);
            // console.timeEnd("Time");
            document.getElementById("alert").classList.remove("invisible");
        }
        
        function commutator(x) {
            const order = 4;
            if (x.toString() === "".toString()) {
                return "Empty input.";
            }
            const arr1 = preprocessing(x);
            if (arr1.length === 0) {
                return "Empty input.";
            }
            for (let i = 0; i < arr1.length - 1; i++) {
                if (arr1[i].length > 2) {
                    return "Invalid input.";
                }
            }
            let sum = 0;
            for (let i = 0; i <= arr1.length - 1; i++) {
                sum = 0;
                for (let j = 0; j <= arr1.length - 1; j++) {
                    if (arr1[i][0] === arr1[j][0]) {
                        if (arr1[j].length === 1) {
                            sum += 1;
                        } else {
                            if (arr1[j][1] === "2") {
                                sum += 2;
                            }
                            if (arr1[j][1] === "'") {
                                sum -= 1;
                            }
                        }
                    }
                }
                if (sum % order !== 0) {
                    return "Not found.";
                }
            }
            let count = 0,
                minscoreall = 10000,
                arrex = [],
                minarr = [];
            const locationud = [];
            for (let i = 0; i < arr1.length - 1; i++) {
                const similarstr = "UD DU UE EU DE ED RM MR RL LR LM ML FS SF FB BF SB BS";
                if (similarstr.toString().indexOf(arr1[i][0].toString() + arr1[i + 1][0].toString()) > -1) {
                    locationud[count] = i;
                    count += 1;
                }
            }
            if (count <= 4) {
                const number = 2 ** count;
                let minscore = 0;
                for (let i = 0; i <= number - 1; i++) {
                    const text = String(i.toString(2));
                    arrex = arr1.concat();
                    for (let j = 0; j < text.length; j++) {
                        if (text[text.length - 1 - j].toString() === "1".toString()) {
                            arrex = swaparr(arrex, locationud[j], locationud[j] + 1);
                        }
                    }
                    const part3 = conjugate(arrex),
                        arr2 = simplify(inverse(part3.concat()).concat(arrex, part3)),
                        penaltyFactor = 2;
                    let arrtemp = arr2.concat(),
                        realscore = 0;
                    minscore = 1000;
                    for (let j = 0; j < arrtemp.length; j++) {
                        if (j <= arrtemp.length / 4 || j >= 3 * arrtemp.length / 4) {
                            const scoreTemp = score(arrtemp.concat());
                            if (j <= arrtemp.length / 2) {
                                realscore = scoreTemp + j / (penaltyFactor + 1) + part3.length / 100;
                            }
                            if (j > arrtemp.length / 2) {
                                realscore = scoreTemp + penaltyFactor * (arrtemp.length - j) / (penaltyFactor + 1) + part3.length / 100;
                            }
                            if (realscore < minscore) {
                                minscore = realscore;
                            }
                            arrtemp = displace(arrtemp);
                        }
                    }
                    if (minscore < minscoreall) {
                        minarr = arrex;
                        minscoreall = minscore;
                    }
                }
            } else {
                minarr = arr1;
            }
            const textOutput = commutatormain(minarr);
            if (textOutput.toString() !== "Not found.".toString()) {
                return textOutput;
            }
            const part3 = conjugate(arr1);
            arrex = simplify(inverse(part3.concat()).concat(arr1, part3));
            return commutatorpair(arrex, part3);
        }
        
        function preprocessing(algValue) {
            let x = "";
            x = algValue.trim();
            x = x.split("").join(" ");
            x = x.replace(/\s+/igu, " ");
            x = x.replace(/[‘]/gu, "'");
            x = x.replace(/[’]/gu, "'");
            x = x.replace(/ '/gu, "'");
            x = x.replace(/ 2/gu, "2");
            x = x.replace(/2'/gu, "2");
            x = x.replace(/'2/gu, "2");
            if (x.indexOf("R") > -1 || x.indexOf("M") > -1) {
                x = x.replace(/r2/gu, "R2 M2");
                x = x.replace(/r'/gu, "R' M");
                x = x.replace(/r/gu, "R M'");
            }
            if (x.indexOf("L") > -1 || x.indexOf("M") > -1) {
                x = x.replace(/l2/gu, "L2 M2");
                x = x.replace(/l'/gu, "L' M'");
                x = x.replace(/l/gu, "L M");
            }
            if (x.indexOf("F") > -1 || x.indexOf("S") > -1) {
                x = x.replace(/f2/gu, "F2 S2");
                x = x.replace(/f'/gu, "F' S'");
                x = x.replace(/f/gu, "F S");
            }
            if (x.indexOf("B") > -1 || x.indexOf("S") > -1) {
                x = x.replace(/b2/gu, "B2 S2");
                x = x.replace(/b'/gu, "B' S");
                x = x.replace(/b/gu, "B S'");
            }
            if (x.indexOf("U") > -1 || x.indexOf("E") > -1) {
                x = x.replace(/u2/gu, "U2 E2");
                x = x.replace(/u'/gu, "U' E");
                x = x.replace(/u/gu, "U E'");
            }
            if (x.indexOf("D") > -1 || x.indexOf("E") > -1) {
                x = x.replace(/d2/gu, "D2 E2");
                x = x.replace(/d'/gu, "D' E'");
                x = x.replace(/d/gu, "D E");
            }
            let arr1 = simplify(x.split(" "));
            // Handle cases like R2 M2 E' R' U' R E R' U R' M2
            const similarstr = "UD DU UE EU DE ED RM MR RL LR LM ML FS SF FB BF SB BS";
            if (arr1.length > 1) {
                if (similarstr.toString().indexOf(arr1[arr1.length - 2][0].toString() + arr1[arr1.length - 1][0].toString()) > -1) {
                    if (arr1[arr1.length - 2][0] === arr1[0][0]) {
                        arr1 = swaparr(arr1, arr1.length - 2, arr1.length - 1);
                    }
                }
                if (similarstr.toString().indexOf(arr1[0][0].toString() + arr1[1][0].toString()) > -1) {
                    if (arr1[1][0] === arr1[arr1.length - 1][0]) {
                        arr1 = swaparr(arr1, 0, 1);
                    }
                }
            }
            return arr1;
        }
        
        function commutatorpair(array, part3) {
            let arr1 = array.concat(),
                minscore = 10000,
                temp = 0,
                output0b = "",
                partb0 = "",
                outputb0 = "",
                outputa1 = "",
                outputa2 = "",
                outputb1 = "",
                outputb2 = "",
                text1 = "",
                commutator1 = "",
                commutator2 = "";
            const lenarr1 = arr1.length;
            if (lenarr1 < 4) {
                return "Not found.";
            }
            for (let displaceIndex = 0; displaceIndex < lenarr1; displaceIndex++) {
                for (let ir = 0; ir <= 2; ir++) {
                    for (let jr = 0; jr <= 2 && ir * jr === 0; jr++) {
                        for (let i = 1; i <= lenarr1 / 2; i++) {
                            const part1x = simplify(repeatEnd(arr1.concat().slice(0, i), ir));
                            for (let j = 1; j <= lenarr1 / 2; j++) {
                                const part2x = simplify(inverse(part1x.concat()).concat(repeatEnd(arr1.concat().slice(0, i + j), jr))),
                                    party = simplify(part2x.concat(part1x));
                                let part1 = part1x,
                                    part2 = part2x;
                                if (party.length < Math.max(part1x.length, part2x.length)) {
                                    if (part1x.length <= part2x.length) {
                                        part1 = part1x;
                                        part2 = party;
                                    } else {
                                        part1 = inverse(part2x.concat());
                                        part2 = party;
                                    }
                                }
                                const arrex = part1.concat(part2, inverse(part1.concat()), inverse(part2.concat())),
                                    arra = simplify(arrex),
                                    arrb = simplify(inverse(arra.concat()).concat(arr1));
                                let partb = commutatormain(arrb);
                                if (partb.toString() !== "Not found.".toString()) {
                                    const realscore0 = part1.length + part2.length + Math.min(part1.length, part2.length),
                                        parta1 = simplifyfinal(part1),
                                        parta2 = simplifyfinal(part2);
                                    if (partb.split("[").length === 3) {
                                        partb = partb.substring(1, partb.length - 1);
                                    }
                                    if (partb.toString().indexOf(":".toString()) > -1) {
                                        partb0 = partb.split(":")[0];
                                    } else {
                                        partb0 = "";
                                    }
                                    const partb1 = partb.split("[")[1].split(",")[0],
                                        partb2 = partb.split(",")[1].split("]")[0],
                                        realscore = partb1.split(" ").length + partb2.split(" ").length + Math.min(partb1.split(" ").length, partb2.split(" ").length) + realscore0;
                                    if (realscore < minscore) {
                                        output0b = array.concat().slice(0, displaceIndex);
                                        outputb0 = partb0;
                                        outputa1 = parta1;
                                        outputa2 = parta2;
                                        outputb1 = partb1;
                                        outputb2 = partb2;
                                        temp = 1;
                                        minscore = realscore;
                                        if (realscore0 === 3 || realscore - realscore0 === 3) {
                                            let output0 = simplify(part3);
                                            if (output0b.toString() !== "".toString()) {
                                                output0 = simplify(part3.concat(output0b));
                                            }
                                            commutator1 = singleOutput("", outputa1, outputa2);
                                            commutator2 = singleOutput(outputb0, outputb1, outputb2);
                                            text1 = twoOutput(simplifyfinal(output0), commutator1, commutator2);
                                            return text1;
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                arr1 = displace(arr1);
            }
            if (temp === 0) {
                return "Not found.";
            }
            let output0 = simplify(part3);
            if (output0b.toString() !== "".toString()) {
                output0 = simplify(part3.concat(output0b));
            }
            commutator1 = singleOutput("", outputa1, outputa2);
            commutator2 = singleOutput(outputb0, outputb1, outputb2);
            text1 = twoOutput(simplifyfinal(output0), commutator1, commutator2);
            return text1;
        }
        
        function twoOutput(setup, commutator1, commutator2) {
            if (document.getElementById("settingsOuterBracket").checked === false) {
                if (setup === "") {
                    return `${commutator1}+${commutator2}`;
                }
                return `${setup}:[${commutator1}+${commutator2}]`;
            }
            if (setup === "") {
                return `[${commutator1}${commutator2}]`;
            }
            return `[${setup}:${commutator1}${commutator2}]`;
        }
        
        function commutatormain(array) {
            const arr0 = array.concat(),
                part3 = conjugate(arr0),
                penaltyFactor = 2;
            let arr1 = simplify(inverse(part3.concat()).concat(arr0, part3)),
                minscore = 2000,
                mini = 0,
                realscore = 0,
                arrtemp = arr1.concat(),
                part4 = "";
            for (let i = 0; i < arrtemp.length; i++) {
                if (i <= arrtemp.length / 4 || i >= 3 * arrtemp.length / 4) {
                    const scoreTemp = score(arrtemp.concat());
                    if (i <= arrtemp.length / 2) {
                        realscore = scoreTemp + i / (penaltyFactor + 1);
                    }
                    if (i > arrtemp.length / 2) {
                        realscore = scoreTemp + penaltyFactor * (arrtemp.length - i) / (penaltyFactor + 1);
                    }
                    if (realscore < minscore) {
                        mini = i;
                        minscore = realscore;
                    }
                }
                arrtemp = displace(arrtemp);
            }
            if (mini <= arrtemp.length / 2) {
                part4 = arr1.concat().slice(0, mini);
                arr1 = simplify(inverse(part4.concat()).concat(arr1, part4));
            } else {
                part4 = inverse(arr1.concat().slice(mini, arrtemp.length).concat());
                arr1 = simplify(inverse(part4.concat()).concat(arr1, part4));
            }
            const part5 = simplify(part3.concat(part4)),
                part5Output = simplifyfinal(part5),
                lenarr1 = arr1.length;
        
            /*
            *  Conjecture:  ir === 0 || jr === 0
            *  For free group, ir === 0 && jr === 0
            */
            for (let ir = 0; ir <= 2; ir++) {
                for (let jr = 0; jr <= 2 && ir * jr === 0; jr++) {
                    for (let i = 1; i <= lenarr1 / 2; i++) {
                        const part1x = simplify(repeatEnd(arr1.concat().slice(0, i), ir)),
                            jmin = Math.max(1, Math.ceil((lenarr1 - 1) / 2 - i));
                        for (let j = jmin; j <= lenarr1 / 2; j++) {
                            const part2x = simplify(inverse(part1x.concat()).concat(repeatEnd(arr1.concat().slice(0, i + j), jr))),
                                party = simplify(part2x.concat(part1x));
                            let part1 = part1x,
                                part2 = part2x;
                            // For S' L M2 D L' D' M2 S D L D' L'
                            if (party.length < Math.max(part1x.length, part2x.length)) {
                                if (part1x.length <= part2x.length) {
                                    part1 = part1x;
                                    part2 = party;
                                } else {
                                    part1 = inverse(part2x.concat());
                                    part2 = party;
                                }
                            }
                            const arrex = part1.concat(part2, inverse(part1.concat()), inverse(part2.concat())),
                                arr = simplify(arrex),
                                part1Output = simplifyfinal(part1),
                                part2Output = simplifyfinal(part2);
                            if (simplify(arr.concat(inverse(arr1.concat()))).length === 0) {
                                return singleOutput(part5Output, part1Output, part2Output);
                            }
                        }
                    }
                }
            }
            return "Not found.";
        }
        
        function singleOutput(setup, commutatora, commutatorb) {
            if (document.getElementById("settingsOuterBracket").checked === false) {
                if (setup === "") {
                    return `[${commutatora},${commutatorb}]`;
                }
                return `${setup}:[${commutatora},${commutatorb}]`;
        
            }
            if (setup === "") {
                return `[${commutatora},${commutatorb}]`;
            }
            return `[${setup}:[${commutatora},${commutatorb}]]`;
        
        
        }
        
        function repeatEnd(array, attempt) {
            const arr = array.concat();
            let arr2 = arr.concat().slice(arr.length - 1, arr.length),
                flag = 0;
            const str = arr2[0].toString();
            if (str.length === 2) {
                if (str[1] === "2") {
                    arr2 = [str[0]];
                    flag = 1;
                }
            }
            if (attempt === 0) {
                return arr;
            }
            if (attempt === 1) {
                return arr.concat(arr2);
            }
            if (attempt === 2 && flag === 0) {
                return arr.concat(arr2, arr2);
            }
            if (attempt === 2 && flag === 1) {
                return arr.concat(arr2, arr2, arr2);
            }
            return null;
        }
        
        // R2 D R U' R D' R' U R D R' U R' D' R U' R
        function displace(array) {
            const arr = array.concat(),
                arr1 = arr.concat().slice(0, 1),
                arr2 = arr.concat().slice(arr.length - 1, arr.length);
            let arrtemp = [];
            if (combineTwo(arr1[0], arr2[0]).toString() === "0".toString()) {
                arrtemp = arr.concat();
                arrtemp = inverse(arr1.concat()).concat(arrtemp, arr1);
                arrtemp = simplify(arrtemp);
            } else {
                arrtemp = arr.concat();
                arrtemp = arr2.concat(arrtemp, inverse(arr2.concat()));
                arrtemp = simplify(arrtemp);
            }
            return arrtemp;
        }
        
        function score(array) {
            const arr1 = array.concat(),
                lenarr1 = arr1.length,
                scoreNotFound = 1000;
            for (let ir = 0; ir <= 2; ir++) {
                for (let jr = 0; jr <= 2 && ir * jr === 0; jr++) {
                    for (let i = 1; i <= lenarr1 / 2; i++) {
                        const part1x = simplify(repeatEnd(arr1.concat().slice(0, i), ir)),
                            jmin = Math.max(1, Math.ceil((lenarr1 - 1) / 2 - i));
                        for (let j = jmin; j <= lenarr1 / 2; j++) {
                            const part2x = simplify(inverse(part1x.concat()).concat(repeatEnd(arr1.concat().slice(0, i + j), jr))),
                                party = simplify(part2x.concat(part1x));
                            let part1 = part1x,
                                part2 = part2x;
                            if (party.length < Math.max(part1x.length, part2x.length)) {
                                if (part1x.length <= part2x.length) {
                                    part1 = part1x;
                                    part2 = party;
                                } else {
                                    part1 = inverse(part2x.concat());
                                    part2 = party;
                                }
                            }
                            const arrex = part1.concat(part2, inverse(part1.concat()), inverse(part2.concat())),
                                arr = simplify(arrex);
                            if (simplify(arr.concat(inverse(arr1.concat()))).length === 0) {
                                return part1.length + part2.length + Math.min(part1.length, part2.length);
                            }
                        }
                    }
                }
            }
            return scoreNotFound;
        }
        
        function conjugate(array) {
            const arr = array.concat();
            let minlen = arr.length,
                t = 0;
            for (let i = 1; i < array.length; i++) {
                const arr1 = arr.concat().slice(0, i),
                    arr2 = inverse(arr1.concat());
                let arrtemp = arr.concat();
                arrtemp = arr2.concat(arrtemp, arr1);
                arrtemp = simplify(arrtemp);
                const len = simplify(arrtemp).length;
                if (len < minlen) {
                    t = i;
                    minlen = len;
                }
            }
            // For  R' U2 R' D R U R' D' R U R, output R' U':[U',R' D R] instead of R' U2:[R' D R,U]
            if (t > 0) {
                if (arr[t - 1].length > 1) {
                    if (arr[t - 1][1].toString() === "2".toString()) {
                        const output0 = simplify(arr.concat().slice(0, t)),
                            output1 = simplify(arr.concat().slice(0, t - 1).concat([arr[t - 1][0]])),
                            output2 = simplify(arr.concat().slice(0, t - 1).concat([inverseOne(arr[t - 1][0])])),
                            len0 = simplify(inverse(output0.concat()).concat(arr, output0)).length,
                            len1 = simplify(inverse(output1.concat()).concat(arr, output1)).length,
                            len2 = simplify(inverse(output2.concat()).concat(arr, output2)).length;
                        if (len0 < len1 && len0 < len2) {
                            return output0;
                        }
                        if (len1 <= len2) {
                            return output1;
                        }
                        return output2;
                    }
                }
            }
            return arr.concat().slice(0, t);
        }
        
        function inverse(array) {
            const arr = array.concat();
            for (let i = 0; i < arr.length / 2; i++) {
                const temp = arr[i];
                arr[i] = array[arr.length - 1 - i];
                arr[arr.length - 1 - i] = temp;
            }
            for (let i = 0; i < arr.length; i++) {
                arr[i] = inverseOne(arr[i]);
            }
            return arr;
        }
        
        function simplifyfinal(array) {
            let arr = array.concat();
            arr = simplify(arr);
            if (arr.length === 0) {
                return "";
            }
            for (let i = 0; i < arr.length - 1; i++) {
                if (arr[i][0].toString() === "D".toString() && arr[i + 1][0].toString() === "U".toString()) {
                    arr = swaparr(arr, i, i + 1);
                }
                if (arr[i][0].toString() === "B".toString() && arr[i + 1][0].toString() === "F".toString()) {
                    arr = swaparr(arr, i, i + 1);
                }
                if (arr[i][0].toString() === "L".toString() && arr[i + 1][0].toString() === "R".toString()) {
                    arr = swaparr(arr, i, i + 1);
                }
            }
            let arrOutput = `${arr.join(" ")} `;
            arrOutput = arrOutput.replace(/R2 M2 /gu, "r2 ");
            arrOutput = arrOutput.replace(/R' M /gu, "r' ");
            arrOutput = arrOutput.replace(/R M' /gu, "r ");
            arrOutput = arrOutput.replace(/L2 M2 /gu, "l2 ");
            arrOutput = arrOutput.replace(/L' M' /gu, "l' ");
            arrOutput = arrOutput.replace(/L M /gu, "l ");
            arrOutput = arrOutput.replace(/F2 S2 /gu, "f2 ");
            arrOutput = arrOutput.replace(/F' S' /gu, "f' ");
            arrOutput = arrOutput.replace(/F S /gu, "f ");
            arrOutput = arrOutput.replace(/B2 S2 /gu, "b2 ");
            arrOutput = arrOutput.replace(/B' S /gu, "b' ");
            arrOutput = arrOutput.replace(/B S' /gu, "b ");
            arrOutput = arrOutput.replace(/U2 E2 /gu, "u2 ");
            arrOutput = arrOutput.replace(/U' E /gu, "u' ");
            arrOutput = arrOutput.replace(/U E' /gu, "u ");
            arrOutput = arrOutput.replace(/D2 E2 /gu, "d2 ");
            arrOutput = arrOutput.replace(/D' E' /gu, "d' ");
            arrOutput = arrOutput.replace(/D E /gu, "d ");
            arrOutput = arrOutput.replace(/M2 R2 /gu, "r2 ");
            arrOutput = arrOutput.replace(/M R' /gu, "r' ");
            arrOutput = arrOutput.replace(/M' R /gu, "r ");
            arrOutput = arrOutput.replace(/M2 L2 /gu, "l2 ");
            arrOutput = arrOutput.replace(/M' L' /gu, "l' ");
            arrOutput = arrOutput.replace(/M L /gu, "l ");
            arrOutput = arrOutput.replace(/S2 F2 /gu, "f2 ");
            arrOutput = arrOutput.replace(/S' F' /gu, "f' ");
            arrOutput = arrOutput.replace(/S F /gu, "f ");
            arrOutput = arrOutput.replace(/S2 B2 /gu, "b2 ");
            arrOutput = arrOutput.replace(/S B' /gu, "b' ");
            arrOutput = arrOutput.replace(/S' B /gu, "b ");
            arrOutput = arrOutput.replace(/E2 U2 /gu, "u2 ");
            arrOutput = arrOutput.replace(/E U' /gu, "u' ");
            arrOutput = arrOutput.replace(/E' U /gu, "u ");
            arrOutput = arrOutput.replace(/E2 D2 /gu, "d2 ");
            arrOutput = arrOutput.replace(/E' D' /gu, "d' ");
            arrOutput = arrOutput.replace(/E D /gu, "d ");
            arrOutput = arrOutput.replace(/R M2 /gu, "r M' ");
            arrOutput = arrOutput.replace(/R' M2 /gu, "r' M ");
            arrOutput = arrOutput.replace(/M2 R /gu, "r M' ");
            arrOutput = arrOutput.replace(/M2 R' /gu, "r' M ");
            arrOutput = arrOutput.substring(0, arrOutput.length - 1);
            return arrOutput;
        }
        
        function simplify(array) {
            const arr = array.concat();
            let i = 0;
            while (i < arr.length - 1) {
                if (combineTwo(arr[i], arr[i + 1]).toString() === "".toString()) {
                    arr.splice(i, 2);
                    i = 0;
                    continue;
                }
                if (combineTwo(arr[i], arr[i + 1]).toString() === arr[i][0].toString()) {
                    arr.splice(i, 2, arr[i][0]);
                    i = 0;
                    continue;
                }
                if (combineTwo(arr[i], arr[i + 1]).toString() === `${arr[i][0]}2`.toString()) {
                    arr.splice(i, 2, `${arr[i][0]}2`);
                    i = 0;
                    continue;
                }
                if (combineTwo(arr[i], arr[i + 1]).toString() === `${arr[i][0]}'`.toString()) {
                    arr.splice(i, 2, `${arr[i][0]}'`);
                    i = 0;
                    continue;
                }
                if (i < arr.length - 2) {
                    const similarstr = "UD DU UE EU DE ED RM MR RL LR LM ML FS SF FB BF SB BS";
                    if (similarstr.toString().indexOf(arr[i][0].toString() + arr[i + 1][0].toString()) > -1) {
                        if (combineTwo(arr[i], arr[i + 2]).toString() === "".toString()) {
                            arr.splice(i + 2, 1);
                            arr.splice(i, 1);
                            i = 0;
                            continue;
                        }
                        if (combineTwo(arr[i], arr[i + 2]).toString() === arr[i][0].toString()) {
                            arr.splice(i + 2, 1);
                            arr.splice(i, 1, arr[i][0]);
                            i = 0;
                            continue;
                        }
                        if (combineTwo(arr[i], arr[i + 2]).toString() === `${arr[i][0]}2`.toString()) {
                            arr.splice(i + 2, 1);
                            arr.splice(i, 1, `${arr[i][0]}2`);
                            i = 0;
                            continue;
                        }
                        if (combineTwo(arr[i], arr[i + 2]).toString() === `${arr[i][0]}'`.toString()) {
                            arr.splice(i + 2, 1);
                            arr.splice(i, 1, `${arr[i][0]}'`);
                            i = 0;
                            continue;
                        }
                    }
                }
                if (i < arr.length - 3) {
                    const similarstr = "UDE DUE UED EUD DEU EDU RML MRL RLM LRM LMR MLR FSB SFB FBS BFS SBF BSF";
                    if (similarstr.toString().indexOf(arr[i][0].toString() + arr[i + 1][0].toString() + arr[i + 2][0].toString()) > -1) {
                        if (combineTwo(arr[i], arr[i + 3]).toString() === "".toString()) {
                            arr.splice(i + 3, 1);
                            arr.splice(i, 1);
                            i = 0;
                            continue;
                        }
                        if (combineTwo(arr[i], arr[i + 3]).toString() === arr[i][0].toString()) {
                            arr.splice(i + 3, 1);
                            arr.splice(i, 1, arr[i][0]);
                            i = 0;
                            continue;
                        }
                        if (combineTwo(arr[i], arr[i + 3]).toString() === `${arr[i][0]}2`.toString()) {
                            arr.splice(i + 3, 1);
                            arr.splice(i, 1, `${arr[i][0]}2`);
                            i = 0;
                            continue;
                        }
                        if (combineTwo(arr[i], arr[i + 3]).toString() === `${arr[i][0]}'`.toString()) {
                            arr.splice(i + 3, 1);
                            arr.splice(i, 1, `${arr[i][0]}'`);
                            i = 0;
                            continue;
                        }
                    }
                }
                i += 1;
            }
            return arr;
        }
        
        function combineTwo(str1, str2) {
            const len1 = str1.length,
                len2 = str2.length;
            if (str1[0] === str2[0]) {
                if (len1 === 1) {
                    if (len2 === 1) {
                        return `${str1}2`;
                    }
                    if (len2 === 2) {
                        if (str2[1] === "2") {
                            return `${str1}'`;
                        }
                        if (str2[1] === "'") {
                            return "";
                        }
                    }
                }
                if (len1 === 2) {
                    if (str1[1] === "'") {
                        if (len2 === 1) {
                            return "";
                        }
                        if (len2 === 2) {
                            if (str2[1] === "2") {
                                return str1[0];
                            }
                            if (str2[1] === "'") {
                                return `${str1[0]}2`;
                            }
                        }
                    }
                    if (str1[1] === "2") {
                        if (len2 === 1) {
                            return `${str1[0]}'`;
                        }
                        if (len2 === 2) {
                            if (str2[1] === "2") {
                                return "";
                            }
                            if (str2[1] === "'") {
                                return str1[0];
                            }
                        }
                    }
                }
            }
            return "0";
        }
        
        function inverseOne(str) {
            const len = str.length;
            if (len === 1) {
                return `${str}'`;
            }
            if (len === 2) {
                if (str[1] === "2") {
                    return str;
                }
                if (str[1] === "'") {
                    return str[0];
                }
            }
            return null;
        }
        
        function swaparr(arr, index1, index2) {
            arr[index1] = arr.splice(index2, 1, arr[index1])[0];
            return arr;
        }
        
        document.getElementById("cube").addEventListener("click", cube);
        document.getElementById("expand").addEventListener("click", expand);
    </code>
      </pre>
  </main>
  <script src="assets/dist/js/bootstrap.bundle.min.js"></script>
  <script src="assets/dist/js/prism.js"></script>
</body>
</html>